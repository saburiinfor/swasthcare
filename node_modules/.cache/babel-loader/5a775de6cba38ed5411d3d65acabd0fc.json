{"ast":null,"code":"/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.4.1): scrollspy.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nimport $ from 'jquery';\nimport Util from './util';\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME = 'scrollspy';\nconst VERSION = '4.4.1';\nconst DATA_KEY = 'bs.scrollspy';\nconst EVENT_KEY = `.${DATA_KEY}`;\nconst DATA_API_KEY = '.data-api';\nconst JQUERY_NO_CONFLICT = $.fn[NAME];\nconst Default = {\n  offset: 10,\n  method: 'auto',\n  target: ''\n};\nconst DefaultType = {\n  offset: 'number',\n  method: 'string',\n  target: '(string|element)'\n};\nconst Event = {\n  ACTIVATE: `activate${EVENT_KEY}`,\n  SCROLL: `scroll${EVENT_KEY}`,\n  LOAD_DATA_API: `load${EVENT_KEY}${DATA_API_KEY}`\n};\nconst ClassName = {\n  DROPDOWN_ITEM: 'dropdown-item',\n  DROPDOWN_MENU: 'dropdown-menu',\n  ACTIVE: 'active'\n};\nconst Selector = {\n  DATA_SPY: '[data-spy=\"scroll\"]',\n  ACTIVE: '.active',\n  NAV_LIST_GROUP: '.nav, .list-group',\n  NAV_LINKS: '.nav-link',\n  NAV_ITEMS: '.nav-item',\n  LIST_ITEMS: '.list-group-item',\n  DROPDOWN: '.dropdown',\n  DROPDOWN_ITEMS: '.dropdown-item',\n  DROPDOWN_TOGGLE: '.dropdown-toggle'\n};\nconst OffsetMethod = {\n  OFFSET: 'offset',\n  POSITION: 'position'\n};\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass ScrollSpy {\n  constructor(element, config) {\n    this._element = element;\n    this._scrollElement = element.tagName === 'BODY' ? window : element;\n    this._config = this._getConfig(config);\n    this._selector = `${this._config.target} ${Selector.NAV_LINKS},` + `${this._config.target} ${Selector.LIST_ITEMS},` + `${this._config.target} ${Selector.DROPDOWN_ITEMS}`;\n    this._offsets = [];\n    this._targets = [];\n    this._activeTarget = null;\n    this._scrollHeight = 0;\n    $(this._scrollElement).on(Event.SCROLL, event => this._process(event));\n    this.refresh();\n\n    this._process();\n  } // Getters\n\n\n  static get VERSION() {\n    return VERSION;\n  }\n\n  static get Default() {\n    return Default;\n  } // Public\n\n\n  refresh() {\n    const autoMethod = this._scrollElement === this._scrollElement.window ? OffsetMethod.OFFSET : OffsetMethod.POSITION;\n    const offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;\n    const offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;\n    this._offsets = [];\n    this._targets = [];\n    this._scrollHeight = this._getScrollHeight();\n    const targets = [].slice.call(document.querySelectorAll(this._selector));\n    targets.map(element => {\n      let target;\n      const targetSelector = Util.getSelectorFromElement(element);\n\n      if (targetSelector) {\n        target = document.querySelector(targetSelector);\n      }\n\n      if (target) {\n        const targetBCR = target.getBoundingClientRect();\n\n        if (targetBCR.width || targetBCR.height) {\n          // TODO (fat): remove sketch reliance on jQuery position/offset\n          return [$(target)[offsetMethod]().top + offsetBase, targetSelector];\n        }\n      }\n\n      return null;\n    }).filter(item => item).sort((a, b) => a[0] - b[0]).forEach(item => {\n      this._offsets.push(item[0]);\n\n      this._targets.push(item[1]);\n    });\n  }\n\n  dispose() {\n    $.removeData(this._element, DATA_KEY);\n    $(this._scrollElement).off(EVENT_KEY);\n    this._element = null;\n    this._scrollElement = null;\n    this._config = null;\n    this._selector = null;\n    this._offsets = null;\n    this._targets = null;\n    this._activeTarget = null;\n    this._scrollHeight = null;\n  } // Private\n\n\n  _getConfig(config) {\n    config = { ...Default,\n      ...(typeof config === 'object' && config ? config : {})\n    };\n\n    if (typeof config.target !== 'string') {\n      let id = $(config.target).attr('id');\n\n      if (!id) {\n        id = Util.getUID(NAME);\n        $(config.target).attr('id', id);\n      }\n\n      config.target = `#${id}`;\n    }\n\n    Util.typeCheckConfig(NAME, config, DefaultType);\n    return config;\n  }\n\n  _getScrollTop() {\n    return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;\n  }\n\n  _getScrollHeight() {\n    return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n  }\n\n  _getOffsetHeight() {\n    return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;\n  }\n\n  _process() {\n    const scrollTop = this._getScrollTop() + this._config.offset;\n\n    const scrollHeight = this._getScrollHeight();\n\n    const maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();\n\n    if (this._scrollHeight !== scrollHeight) {\n      this.refresh();\n    }\n\n    if (scrollTop >= maxScroll) {\n      const target = this._targets[this._targets.length - 1];\n\n      if (this._activeTarget !== target) {\n        this._activate(target);\n      }\n\n      return;\n    }\n\n    if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {\n      this._activeTarget = null;\n\n      this._clear();\n\n      return;\n    }\n\n    const offsetLength = this._offsets.length;\n\n    for (let i = offsetLength; i--;) {\n      const isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);\n\n      if (isActiveTarget) {\n        this._activate(this._targets[i]);\n      }\n    }\n  }\n\n  _activate(target) {\n    this._activeTarget = target;\n\n    this._clear();\n\n    const queries = this._selector.split(',').map(selector => `${selector}[data-target=\"${target}\"],${selector}[href=\"${target}\"]`);\n\n    const $link = $([].slice.call(document.querySelectorAll(queries.join(','))));\n\n    if ($link.hasClass(ClassName.DROPDOWN_ITEM)) {\n      $link.closest(Selector.DROPDOWN).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);\n      $link.addClass(ClassName.ACTIVE);\n    } else {\n      // Set triggered link as active\n      $link.addClass(ClassName.ACTIVE); // Set triggered links parents as active\n      // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\n\n      $link.parents(Selector.NAV_LIST_GROUP).prev(`${Selector.NAV_LINKS}, ${Selector.LIST_ITEMS}`).addClass(ClassName.ACTIVE); // Handle special case when .nav-link is inside .nav-item\n\n      $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_ITEMS).children(Selector.NAV_LINKS).addClass(ClassName.ACTIVE);\n    }\n\n    $(this._scrollElement).trigger(Event.ACTIVATE, {\n      relatedTarget: target\n    });\n  }\n\n  _clear() {\n    [].slice.call(document.querySelectorAll(this._selector)).filter(node => node.classList.contains(ClassName.ACTIVE)).forEach(node => node.classList.remove(ClassName.ACTIVE));\n  } // Static\n\n\n  static _jQueryInterface(config) {\n    return this.each(function () {\n      let data = $(this).data(DATA_KEY);\n\n      const _config = typeof config === 'object' && config;\n\n      if (!data) {\n        data = new ScrollSpy(this, _config);\n        $(this).data(DATA_KEY, data);\n      }\n\n      if (typeof config === 'string') {\n        if (typeof data[config] === 'undefined') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config]();\n      }\n    });\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * Data Api implementation\n * ------------------------------------------------------------------------\n */\n\n\n$(window).on(Event.LOAD_DATA_API, () => {\n  const scrollSpys = [].slice.call(document.querySelectorAll(Selector.DATA_SPY));\n  const scrollSpysLength = scrollSpys.length;\n\n  for (let i = scrollSpysLength; i--;) {\n    const $spy = $(scrollSpys[i]);\n\n    ScrollSpy._jQueryInterface.call($spy, $spy.data());\n  }\n});\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n */\n\n$.fn[NAME] = ScrollSpy._jQueryInterface;\n$.fn[NAME].Constructor = ScrollSpy;\n\n$.fn[NAME].noConflict = () => {\n  $.fn[NAME] = JQUERY_NO_CONFLICT;\n  return ScrollSpy._jQueryInterface;\n};\n\nexport default ScrollSpy;","map":null,"metadata":{},"sourceType":"module"}