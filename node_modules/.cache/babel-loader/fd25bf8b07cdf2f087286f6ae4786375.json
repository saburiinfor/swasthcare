{"ast":null,"code":"/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.4.1): tooltip.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nimport { DefaultWhitelist, sanitizeHtml } from './tools/sanitizer';\nimport $ from 'jquery';\nimport Popper from 'popper.js';\nimport Util from './util';\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME = 'tooltip';\nconst VERSION = '4.4.1';\nconst DATA_KEY = 'bs.tooltip';\nconst EVENT_KEY = `.${DATA_KEY}`;\nconst JQUERY_NO_CONFLICT = $.fn[NAME];\nconst CLASS_PREFIX = 'bs-tooltip';\nconst BSCLS_PREFIX_REGEX = new RegExp(`(^|\\\\s)${CLASS_PREFIX}\\\\S+`, 'g');\nconst DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];\nconst DefaultType = {\n  animation: 'boolean',\n  template: 'string',\n  title: '(string|element|function)',\n  trigger: 'string',\n  delay: '(number|object)',\n  html: 'boolean',\n  selector: '(string|boolean)',\n  placement: '(string|function)',\n  offset: '(number|string|function)',\n  container: '(string|element|boolean)',\n  fallbackPlacement: '(string|array)',\n  boundary: '(string|element)',\n  sanitize: 'boolean',\n  sanitizeFn: '(null|function)',\n  whiteList: 'object',\n  popperConfig: '(null|object)'\n};\nconst AttachmentMap = {\n  AUTO: 'auto',\n  TOP: 'top',\n  RIGHT: 'right',\n  BOTTOM: 'bottom',\n  LEFT: 'left'\n};\nconst Default = {\n  animation: true,\n  template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"arrow\"></div>' + '<div class=\"tooltip-inner\"></div></div>',\n  trigger: 'hover focus',\n  title: '',\n  delay: 0,\n  html: false,\n  selector: false,\n  placement: 'top',\n  offset: 0,\n  container: false,\n  fallbackPlacement: 'flip',\n  boundary: 'scrollParent',\n  sanitize: true,\n  sanitizeFn: null,\n  whiteList: DefaultWhitelist,\n  popperConfig: null\n};\nconst HoverState = {\n  SHOW: 'show',\n  OUT: 'out'\n};\nconst Event = {\n  HIDE: `hide${EVENT_KEY}`,\n  HIDDEN: `hidden${EVENT_KEY}`,\n  SHOW: `show${EVENT_KEY}`,\n  SHOWN: `shown${EVENT_KEY}`,\n  INSERTED: `inserted${EVENT_KEY}`,\n  CLICK: `click${EVENT_KEY}`,\n  FOCUSIN: `focusin${EVENT_KEY}`,\n  FOCUSOUT: `focusout${EVENT_KEY}`,\n  MOUSEENTER: `mouseenter${EVENT_KEY}`,\n  MOUSELEAVE: `mouseleave${EVENT_KEY}`\n};\nconst ClassName = {\n  FADE: 'fade',\n  SHOW: 'show'\n};\nconst Selector = {\n  TOOLTIP: '.tooltip',\n  TOOLTIP_INNER: '.tooltip-inner',\n  ARROW: '.arrow'\n};\nconst Trigger = {\n  HOVER: 'hover',\n  FOCUS: 'focus',\n  CLICK: 'click',\n  MANUAL: 'manual'\n};\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass Tooltip {\n  constructor(element, config) {\n    if (typeof Popper === 'undefined') {\n      throw new TypeError('Bootstrap\\'s tooltips require Popper.js (https://popper.js.org/)');\n    } // private\n\n\n    this._isEnabled = true;\n    this._timeout = 0;\n    this._hoverState = '';\n    this._activeTrigger = {};\n    this._popper = null; // Protected\n\n    this.element = element;\n    this.config = this._getConfig(config);\n    this.tip = null;\n\n    this._setListeners();\n  } // Getters\n\n\n  static get VERSION() {\n    return VERSION;\n  }\n\n  static get Default() {\n    return Default;\n  }\n\n  static get NAME() {\n    return NAME;\n  }\n\n  static get DATA_KEY() {\n    return DATA_KEY;\n  }\n\n  static get Event() {\n    return Event;\n  }\n\n  static get EVENT_KEY() {\n    return EVENT_KEY;\n  }\n\n  static get DefaultType() {\n    return DefaultType;\n  } // Public\n\n\n  enable() {\n    this._isEnabled = true;\n  }\n\n  disable() {\n    this._isEnabled = false;\n  }\n\n  toggleEnabled() {\n    this._isEnabled = !this._isEnabled;\n  }\n\n  toggle(event) {\n    if (!this._isEnabled) {\n      return;\n    }\n\n    if (event) {\n      const dataKey = this.constructor.DATA_KEY;\n      let context = $(event.currentTarget).data(dataKey);\n\n      if (!context) {\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n        $(event.currentTarget).data(dataKey, context);\n      }\n\n      context._activeTrigger.click = !context._activeTrigger.click;\n\n      if (context._isWithActiveTrigger()) {\n        context._enter(null, context);\n      } else {\n        context._leave(null, context);\n      }\n    } else {\n      if ($(this.getTipElement()).hasClass(ClassName.SHOW)) {\n        this._leave(null, this);\n\n        return;\n      }\n\n      this._enter(null, this);\n    }\n  }\n\n  dispose() {\n    clearTimeout(this._timeout);\n    $.removeData(this.element, this.constructor.DATA_KEY);\n    $(this.element).off(this.constructor.EVENT_KEY);\n    $(this.element).closest('.modal').off('hide.bs.modal', this._hideModalHandler);\n\n    if (this.tip) {\n      $(this.tip).remove();\n    }\n\n    this._isEnabled = null;\n    this._timeout = null;\n    this._hoverState = null;\n    this._activeTrigger = null;\n\n    if (this._popper) {\n      this._popper.destroy();\n    }\n\n    this._popper = null;\n    this.element = null;\n    this.config = null;\n    this.tip = null;\n  }\n\n  show() {\n    if ($(this.element).css('display') === 'none') {\n      throw new Error('Please use show on visible elements');\n    }\n\n    const showEvent = $.Event(this.constructor.Event.SHOW);\n\n    if (this.isWithContent() && this._isEnabled) {\n      $(this.element).trigger(showEvent);\n      const shadowRoot = Util.findShadowRoot(this.element);\n      const isInTheDom = $.contains(shadowRoot !== null ? shadowRoot : this.element.ownerDocument.documentElement, this.element);\n\n      if (showEvent.isDefaultPrevented() || !isInTheDom) {\n        return;\n      }\n\n      const tip = this.getTipElement();\n      const tipId = Util.getUID(this.constructor.NAME);\n      tip.setAttribute('id', tipId);\n      this.element.setAttribute('aria-describedby', tipId);\n      this.setContent();\n\n      if (this.config.animation) {\n        $(tip).addClass(ClassName.FADE);\n      }\n\n      const placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;\n\n      const attachment = this._getAttachment(placement);\n\n      this.addAttachmentClass(attachment);\n\n      const container = this._getContainer();\n\n      $(tip).data(this.constructor.DATA_KEY, this);\n\n      if (!$.contains(this.element.ownerDocument.documentElement, this.tip)) {\n        $(tip).appendTo(container);\n      }\n\n      $(this.element).trigger(this.constructor.Event.INSERTED);\n      this._popper = new Popper(this.element, tip, this._getPopperConfig(attachment));\n      $(tip).addClass(ClassName.SHOW); // If this is a touch-enabled device we add extra\n      // empty mouseover listeners to the body's immediate children;\n      // only needed because of broken event delegation on iOS\n      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n      if ('ontouchstart' in document.documentElement) {\n        $(document.body).children().on('mouseover', null, $.noop);\n      }\n\n      const complete = () => {\n        if (this.config.animation) {\n          this._fixTransition();\n        }\n\n        const prevHoverState = this._hoverState;\n        this._hoverState = null;\n        $(this.element).trigger(this.constructor.Event.SHOWN);\n\n        if (prevHoverState === HoverState.OUT) {\n          this._leave(null, this);\n        }\n      };\n\n      if ($(this.tip).hasClass(ClassName.FADE)) {\n        const transitionDuration = Util.getTransitionDurationFromElement(this.tip);\n        $(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n    }\n  }\n\n  hide(callback) {\n    const tip = this.getTipElement();\n    const hideEvent = $.Event(this.constructor.Event.HIDE);\n\n    const complete = () => {\n      if (this._hoverState !== HoverState.SHOW && tip.parentNode) {\n        tip.parentNode.removeChild(tip);\n      }\n\n      this._cleanTipClass();\n\n      this.element.removeAttribute('aria-describedby');\n      $(this.element).trigger(this.constructor.Event.HIDDEN);\n\n      if (this._popper !== null) {\n        this._popper.destroy();\n      }\n\n      if (callback) {\n        callback();\n      }\n    };\n\n    $(this.element).trigger(hideEvent);\n\n    if (hideEvent.isDefaultPrevented()) {\n      return;\n    }\n\n    $(tip).removeClass(ClassName.SHOW); // If this is a touch-enabled device we remove the extra\n    // empty mouseover listeners we added for iOS support\n\n    if ('ontouchstart' in document.documentElement) {\n      $(document.body).children().off('mouseover', null, $.noop);\n    }\n\n    this._activeTrigger[Trigger.CLICK] = false;\n    this._activeTrigger[Trigger.FOCUS] = false;\n    this._activeTrigger[Trigger.HOVER] = false;\n\n    if ($(this.tip).hasClass(ClassName.FADE)) {\n      const transitionDuration = Util.getTransitionDurationFromElement(tip);\n      $(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n    } else {\n      complete();\n    }\n\n    this._hoverState = '';\n  }\n\n  update() {\n    if (this._popper !== null) {\n      this._popper.scheduleUpdate();\n    }\n  } // Protected\n\n\n  isWithContent() {\n    return Boolean(this.getTitle());\n  }\n\n  addAttachmentClass(attachment) {\n    $(this.getTipElement()).addClass(`${CLASS_PREFIX}-${attachment}`);\n  }\n\n  getTipElement() {\n    this.tip = this.tip || $(this.config.template)[0];\n    return this.tip;\n  }\n\n  setContent() {\n    const tip = this.getTipElement();\n    this.setElementContent($(tip.querySelectorAll(Selector.TOOLTIP_INNER)), this.getTitle());\n    $(tip).removeClass(`${ClassName.FADE} ${ClassName.SHOW}`);\n  }\n\n  setElementContent($element, content) {\n    if (typeof content === 'object' && (content.nodeType || content.jquery)) {\n      // Content is a DOM node or a jQuery\n      if (this.config.html) {\n        if (!$(content).parent().is($element)) {\n          $element.empty().append(content);\n        }\n      } else {\n        $element.text($(content).text());\n      }\n\n      return;\n    }\n\n    if (this.config.html) {\n      if (this.config.sanitize) {\n        content = sanitizeHtml(content, this.config.whiteList, this.config.sanitizeFn);\n      }\n\n      $element.html(content);\n    } else {\n      $element.text(content);\n    }\n  }\n\n  getTitle() {\n    let title = this.element.getAttribute('data-original-title');\n\n    if (!title) {\n      title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;\n    }\n\n    return title;\n  } // Private\n\n\n  _getPopperConfig(attachment) {\n    const defaultBsConfig = {\n      placement: attachment,\n      modifiers: {\n        offset: this._getOffset(),\n        flip: {\n          behavior: this.config.fallbackPlacement\n        },\n        arrow: {\n          element: Selector.ARROW\n        },\n        preventOverflow: {\n          boundariesElement: this.config.boundary\n        }\n      },\n      onCreate: data => {\n        if (data.originalPlacement !== data.placement) {\n          this._handlePopperPlacementChange(data);\n        }\n      },\n      onUpdate: data => this._handlePopperPlacementChange(data)\n    };\n    return { ...defaultBsConfig,\n      ...this.config.popperConfig\n    };\n  }\n\n  _getOffset() {\n    const offset = {};\n\n    if (typeof this.config.offset === 'function') {\n      offset.fn = data => {\n        data.offsets = { ...data.offsets,\n          ...(this.config.offset(data.offsets, this.element) || {})\n        };\n        return data;\n      };\n    } else {\n      offset.offset = this.config.offset;\n    }\n\n    return offset;\n  }\n\n  _getContainer() {\n    if (this.config.container === false) {\n      return document.body;\n    }\n\n    if (Util.isElement(this.config.container)) {\n      return $(this.config.container);\n    }\n\n    return $(document).find(this.config.container);\n  }\n\n  _getAttachment(placement) {\n    return AttachmentMap[placement.toUpperCase()];\n  }\n\n  _setListeners() {\n    const triggers = this.config.trigger.split(' ');\n    triggers.forEach(trigger => {\n      if (trigger === 'click') {\n        $(this.element).on(this.constructor.Event.CLICK, this.config.selector, event => this.toggle(event));\n      } else if (trigger !== Trigger.MANUAL) {\n        const eventIn = trigger === Trigger.HOVER ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN;\n        const eventOut = trigger === Trigger.HOVER ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;\n        $(this.element).on(eventIn, this.config.selector, event => this._enter(event)).on(eventOut, this.config.selector, event => this._leave(event));\n      }\n    });\n\n    this._hideModalHandler = () => {\n      if (this.element) {\n        this.hide();\n      }\n    };\n\n    $(this.element).closest('.modal').on('hide.bs.modal', this._hideModalHandler);\n\n    if (this.config.selector) {\n      this.config = { ...this.config,\n        trigger: 'manual',\n        selector: ''\n      };\n    } else {\n      this._fixTitle();\n    }\n  }\n\n  _fixTitle() {\n    const titleType = typeof this.element.getAttribute('data-original-title');\n\n    if (this.element.getAttribute('title') || titleType !== 'string') {\n      this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');\n      this.element.setAttribute('title', '');\n    }\n  }\n\n  _enter(event, context) {\n    const dataKey = this.constructor.DATA_KEY;\n    context = context || $(event.currentTarget).data(dataKey);\n\n    if (!context) {\n      context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n      $(event.currentTarget).data(dataKey, context);\n    }\n\n    if (event) {\n      context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;\n    }\n\n    if ($(context.getTipElement()).hasClass(ClassName.SHOW) || context._hoverState === HoverState.SHOW) {\n      context._hoverState = HoverState.SHOW;\n      return;\n    }\n\n    clearTimeout(context._timeout);\n    context._hoverState = HoverState.SHOW;\n\n    if (!context.config.delay || !context.config.delay.show) {\n      context.show();\n      return;\n    }\n\n    context._timeout = setTimeout(() => {\n      if (context._hoverState === HoverState.SHOW) {\n        context.show();\n      }\n    }, context.config.delay.show);\n  }\n\n  _leave(event, context) {\n    const dataKey = this.constructor.DATA_KEY;\n    context = context || $(event.currentTarget).data(dataKey);\n\n    if (!context) {\n      context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n      $(event.currentTarget).data(dataKey, context);\n    }\n\n    if (event) {\n      context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;\n    }\n\n    if (context._isWithActiveTrigger()) {\n      return;\n    }\n\n    clearTimeout(context._timeout);\n    context._hoverState = HoverState.OUT;\n\n    if (!context.config.delay || !context.config.delay.hide) {\n      context.hide();\n      return;\n    }\n\n    context._timeout = setTimeout(() => {\n      if (context._hoverState === HoverState.OUT) {\n        context.hide();\n      }\n    }, context.config.delay.hide);\n  }\n\n  _isWithActiveTrigger() {\n    for (const trigger in this._activeTrigger) {\n      if (this._activeTrigger[trigger]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _getConfig(config) {\n    const dataAttributes = $(this.element).data();\n    Object.keys(dataAttributes).forEach(dataAttr => {\n      if (DISALLOWED_ATTRIBUTES.indexOf(dataAttr) !== -1) {\n        delete dataAttributes[dataAttr];\n      }\n    });\n    config = { ...this.constructor.Default,\n      ...dataAttributes,\n      ...(typeof config === 'object' && config ? config : {})\n    };\n\n    if (typeof config.delay === 'number') {\n      config.delay = {\n        show: config.delay,\n        hide: config.delay\n      };\n    }\n\n    if (typeof config.title === 'number') {\n      config.title = config.title.toString();\n    }\n\n    if (typeof config.content === 'number') {\n      config.content = config.content.toString();\n    }\n\n    Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);\n\n    if (config.sanitize) {\n      config.template = sanitizeHtml(config.template, config.whiteList, config.sanitizeFn);\n    }\n\n    return config;\n  }\n\n  _getDelegateConfig() {\n    const config = {};\n\n    if (this.config) {\n      for (const key in this.config) {\n        if (this.constructor.Default[key] !== this.config[key]) {\n          config[key] = this.config[key];\n        }\n      }\n    }\n\n    return config;\n  }\n\n  _cleanTipClass() {\n    const $tip = $(this.getTipElement());\n    const tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);\n\n    if (tabClass !== null && tabClass.length) {\n      $tip.removeClass(tabClass.join(''));\n    }\n  }\n\n  _handlePopperPlacementChange(popperData) {\n    const popperInstance = popperData.instance;\n    this.tip = popperInstance.popper;\n\n    this._cleanTipClass();\n\n    this.addAttachmentClass(this._getAttachment(popperData.placement));\n  }\n\n  _fixTransition() {\n    const tip = this.getTipElement();\n    const initConfigAnimation = this.config.animation;\n\n    if (tip.getAttribute('x-placement') !== null) {\n      return;\n    }\n\n    $(tip).removeClass(ClassName.FADE);\n    this.config.animation = false;\n    this.hide();\n    this.show();\n    this.config.animation = initConfigAnimation;\n  } // Static\n\n\n  static _jQueryInterface(config) {\n    return this.each(function () {\n      let data = $(this).data(DATA_KEY);\n\n      const _config = typeof config === 'object' && config;\n\n      if (!data && /dispose|hide/.test(config)) {\n        return;\n      }\n\n      if (!data) {\n        data = new Tooltip(this, _config);\n        $(this).data(DATA_KEY, data);\n      }\n\n      if (typeof config === 'string') {\n        if (typeof data[config] === 'undefined') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config]();\n      }\n    });\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n */\n\n\n$.fn[NAME] = Tooltip._jQueryInterface;\n$.fn[NAME].Constructor = Tooltip;\n\n$.fn[NAME].noConflict = () => {\n  $.fn[NAME] = JQUERY_NO_CONFLICT;\n  return Tooltip._jQueryInterface;\n};\n\nexport default Tooltip;","map":null,"metadata":{},"sourceType":"module"}